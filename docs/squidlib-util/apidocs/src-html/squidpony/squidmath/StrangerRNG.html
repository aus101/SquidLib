<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (16) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: squidpony.squidmath, class: StrangerRNG">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line.1">package squidpony.squidmath;</span>
<span class="source-line-no">002</span><span id="line.2"></span>
<span class="source-line-no">003</span><span id="line.3">import squidpony.StringKit;</span>
<span class="source-line-no">004</span><span id="line.4"></span>
<span class="source-line-no">005</span><span id="line.5">import java.io.Serializable;</span>
<span class="source-line-no">006</span><span id="line.6"></span>
<span class="source-line-no">007</span><span id="line.7">/**</span>
<span class="source-line-no">008</span><span id="line.8"> * A RandomnessSource with four {@code long} states that changes its state with complex ways it can connect states to</span>
<span class="source-line-no">009</span><span id="line.9"> * other states. This has been backported from jdkgdxds. This generator has a known minimum period of (2 to the 65) - 2,</span>
<span class="source-line-no">010</span><span id="line.10"> * but a shorter probable maximum period than {@link FourWheelRNG} (which has no guarantee on minimum period). It is a</span>
<span class="source-line-no">011</span><span id="line.11"> * very fast generator on Java 16 and newer, though slower than FourWheelRNG when multiplication is fast on the platform</span>
<span class="source-line-no">012</span><span id="line.12"> * in question. It's about 30% faster than Java 17's built-in Xoshiro256PlusPlus when also run on Java 17; both use no</span>
<span class="source-line-no">013</span><span id="line.13"> * multiplication and have the same state size. It's unusually slower on Java 8, relative to more recent JDKs like 16 or</span>
<span class="source-line-no">014</span><span id="line.14"> * 17; on Java 8 specifically, you might prefer FourWheelRNG or {@link TricycleRNG}.</span>
<span class="source-line-no">015</span><span id="line.15"> * &lt;br&gt;</span>
<span class="source-line-no">016</span><span id="line.16"> * StrangerRNG has an unusual structure that uses no multiplication. Its core is in two states, A and B, that interleave</span>
<span class="source-line-no">017</span><span id="line.17"> * a 64-bit xorshift generator in each state, with A reaching a "complete" return value when B has not, and vice versa.</span>
<span class="source-line-no">018</span><span id="line.18"> * Each of the interleaved generators has a period of (2 to the 64) - 1 "complete" return values, which makes the two</span>
<span class="source-line-no">019</span><span id="line.19"> * generators have a combined period of (2 to the 65) - 2 . The A and B states must be significantly different for this</span>
<span class="source-line-no">020</span><span id="line.20"> * to pass testing, so the seeding for this class takes advantage of the presence of a fast jump algorithm for the</span>
<span class="source-line-no">021</span><span id="line.21"> * xorshift generator, and jumps B ahead of A by {@code 0x9E3779B97F4A7C15} (or 11.4 quintillion) steps forward. States</span>
<span class="source-line-no">022</span><span id="line.22"> * C and D are more typical; C incorporates a rotated D and B, while D incorporates C, A, and a large additive constant.</span>
<span class="source-line-no">023</span><span id="line.23"> * This class returns the C state as it was before next state is calculated, as an optimization, so it is recommended</span>
<span class="source-line-no">024</span><span id="line.24"> * that you set the state with one long, or with three longs that are sufficiently random already for your purposes.</span>
<span class="source-line-no">025</span><span id="line.25"> * Both the one- and three-parameter setSeed() methods separate the A and B states by many steps; the one-parameter</span>
<span class="source-line-no">026</span><span id="line.26"> * setSeed() also randomizes state C so the first result returned will be randomly different from the seed.</span>
<span class="source-line-no">027</span><span id="line.27"> * &lt;br&gt;</span>
<span class="source-line-no">028</span><span id="line.28"> * This generator has been tested thoroughly; it has passed 64TB of PractRand testing with no anomalies, 6PB of hwd</span>
<span class="source-line-no">029</span><span id="line.29"> * testing, and multiple weeks of testing for differences from the expected frequency of "extinction" (where the bitwise</span>
<span class="source-line-no">030</span><span id="line.30"> * AND of outputs becomes 0) or "saturation" (where the bitwise OR of outputs becomes all 1s) events in short output</span>
<span class="source-line-no">031</span><span id="line.31"> * sequences.</span>
<span class="source-line-no">032</span><span id="line.32"> * &lt;br&gt;</span>
<span class="source-line-no">033</span><span id="line.33"> * Stranger has two states that perpetually circle each other, never getting closer and remaining strangers to each</span>
<span class="source-line-no">034</span><span id="line.34"> * other. This algorithm should also be faster on "stranger" hardware that doesn't behave like x86_64, like code that</span>
<span class="source-line-no">035</span><span id="line.35"> * runs on the GPU.</span>
<span class="source-line-no">036</span><span id="line.36"> * &lt;br&gt;</span>
<span class="source-line-no">037</span><span id="line.37"> * Created by Tommy Ettinger on 10/8/2021, with substantial help from Spencer Fleming on the jump() method.</span>
<span class="source-line-no">038</span><span id="line.38"> */</span>
<span class="source-line-no">039</span><span id="line.39">public class StrangerRNG implements RandomnessSource, Serializable {</span>
<span class="source-line-no">040</span><span id="line.40">    private static final long serialVersionUID = 0L;</span>
<span class="source-line-no">041</span><span id="line.41">    /**</span>
<span class="source-line-no">042</span><span id="line.42">     * Can be any long value except 0.</span>
<span class="source-line-no">043</span><span id="line.43">     */</span>
<span class="source-line-no">044</span><span id="line.44">    protected long stateA;</span>
<span class="source-line-no">045</span><span id="line.45"></span>
<span class="source-line-no">046</span><span id="line.46">    /**</span>
<span class="source-line-no">047</span><span id="line.47">     * Can be any long value except 0, and should be very distant from stateA in the xorshift sequence.</span>
<span class="source-line-no">048</span><span id="line.48">     */</span>
<span class="source-line-no">049</span><span id="line.49">    protected long stateB;</span>
<span class="source-line-no">050</span><span id="line.50"></span>
<span class="source-line-no">051</span><span id="line.51">    /**</span>
<span class="source-line-no">052</span><span id="line.52">     * Can be any long value; will be returned verbatim from {@link #nextLong()} and only change for the next call.</span>
<span class="source-line-no">053</span><span id="line.53">     */</span>
<span class="source-line-no">054</span><span id="line.54">    protected long stateC;</span>
<span class="source-line-no">055</span><span id="line.55"></span>
<span class="source-line-no">056</span><span id="line.56">    /**</span>
<span class="source-line-no">057</span><span id="line.57">     * Can be any long value.</span>
<span class="source-line-no">058</span><span id="line.58">     */</span>
<span class="source-line-no">059</span><span id="line.59">    protected long stateD;</span>
<span class="source-line-no">060</span><span id="line.60"></span>
<span class="source-line-no">061</span><span id="line.61">    /**</span>
<span class="source-line-no">062</span><span id="line.62">     * Jumps {@code state} ahead by 0x9E3779B97F4A7C15 steps of the generator StrangerRandom uses for its stateA</span>
<span class="source-line-no">063</span><span id="line.63">     * and stateB. When used how it is here, it ensures stateB is 11.4 quintillion steps ahead of stateA in their</span>
<span class="source-line-no">064</span><span id="line.64">     * shared sequence, or 7 quintillion behind if you look at it another way. It would typically take years of</span>
<span class="source-line-no">065</span><span id="line.65">     * continuously running this generator at 100GB/s to have stateA become any state that stateB has already been.</span>
<span class="source-line-no">066</span><span id="line.66">     * Users only need this function if setting stateB by-hand; in that case, {@code state} should be their stateA.</span>
<span class="source-line-no">067</span><span id="line.67">     * &lt;br&gt;</span>
<span class="source-line-no">068</span><span id="line.68">     * Massive credit to Spencer Fleming for writing essentially all of this function over several days.</span>
<span class="source-line-no">069</span><span id="line.69">     * @param state the initial state of a 7-9 xorshift generator</span>
<span class="source-line-no">070</span><span id="line.70">     * @return state jumped ahead 0x9E3779B97F4A7C15 times (unsigned)</span>
<span class="source-line-no">071</span><span id="line.71">     */</span>
<span class="source-line-no">072</span><span id="line.72">    public static long jump(long state){</span>
<span class="source-line-no">073</span><span id="line.73">        final long poly = 0x5556837749D9A17FL;</span>
<span class="source-line-no">074</span><span id="line.74">        long val = 0L, b = 1L;</span>
<span class="source-line-no">075</span><span id="line.75">        for (int i = 0; i &lt; 63; i++, b &lt;&lt;= 1) {</span>
<span class="source-line-no">076</span><span id="line.76">            if((poly &amp; b) != 0L) val ^= state;</span>
<span class="source-line-no">077</span><span id="line.77">            state ^= state &lt;&lt; 7;</span>
<span class="source-line-no">078</span><span id="line.78">            state ^= state &gt;&gt;&gt; 9;</span>
<span class="source-line-no">079</span><span id="line.79">        }</span>
<span class="source-line-no">080</span><span id="line.80">        return val;</span>
<span class="source-line-no">081</span><span id="line.81">    }</span>
<span class="source-line-no">082</span><span id="line.82"></span>
<span class="source-line-no">083</span><span id="line.83">    /**</span>
<span class="source-line-no">084</span><span id="line.84">     * Creates a new generator seeded using Math.random.</span>
<span class="source-line-no">085</span><span id="line.85">     */</span>
<span class="source-line-no">086</span><span id="line.86">    public StrangerRNG() {</span>
<span class="source-line-no">087</span><span id="line.87">        this((long) ((Math.random() - 0.5) * 0x10000000000000L)</span>
<span class="source-line-no">088</span><span id="line.88">                ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L),</span>
<span class="source-line-no">089</span><span id="line.89">                (long) ((Math.random() - 0.5) * 0x10000000000000L)</span>
<span class="source-line-no">090</span><span id="line.90">                ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L),</span>
<span class="source-line-no">091</span><span id="line.91">                (long) ((Math.random() - 0.5) * 0x10000000000000L)</span>
<span class="source-line-no">092</span><span id="line.92">                ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L),</span>
<span class="source-line-no">093</span><span id="line.93">                (long) ((Math.random() - 0.5) * 0x10000000000000L)</span>
<span class="source-line-no">094</span><span id="line.94">                ^ (long) (((Math.random() - 0.5) * 2.0) * 0x8000000000000000L));</span>
<span class="source-line-no">095</span><span id="line.95">    }</span>
<span class="source-line-no">096</span><span id="line.96"></span>
<span class="source-line-no">097</span><span id="line.97">    public StrangerRNG(long seed) {</span>
<span class="source-line-no">098</span><span id="line.98">        setSeed(seed);</span>
<span class="source-line-no">099</span><span id="line.99">    }</span>
<span class="source-line-no">100</span><span id="line.100"></span>
<span class="source-line-no">101</span><span id="line.101">    public StrangerRNG(final long seedA, final long seedB, long seedC, long seedD) {</span>
<span class="source-line-no">102</span><span id="line.102">        this.stateA = (seedA == 0L) ? 0xD3833E804F4C574BL : seedA;</span>
<span class="source-line-no">103</span><span id="line.103">        this.stateB = (seedB == 0L) ? 0x790B300BF9FE738FL : seedB;</span>
<span class="source-line-no">104</span><span id="line.104">        this.stateC = seedC;</span>
<span class="source-line-no">105</span><span id="line.105">        this.stateD = seedD;</span>
<span class="source-line-no">106</span><span id="line.106">    }</span>
<span class="source-line-no">107</span><span id="line.107"></span>
<span class="source-line-no">108</span><span id="line.108">    /**</span>
<span class="source-line-no">109</span><span id="line.109">     * This initializes all 4 states of the generator to random values based on the given seed.</span>
<span class="source-line-no">110</span><span id="line.110">     * (2 to the 64) possible initial generator states can be produced here, all with a different</span>
<span class="source-line-no">111</span><span id="line.111">     * first value returned by {@link #nextLong()} (because {@code stateC} is guaranteed to be</span>
<span class="source-line-no">112</span><span id="line.112">     * different for every non-zero {@code seed}). This ensures stateB is a sufficient distance</span>
<span class="source-line-no">113</span><span id="line.113">     * from stateA in their shared sequence, and also does some randomizing on the seed before it</span>
<span class="source-line-no">114</span><span id="line.114">     * assigns the result to stateC. This isn't an instantaneously-fast method to call like some</span>
<span class="source-line-no">115</span><span id="line.115">     * versions of setSeed(), but it shouldn't be too slow unless it is called before every</span>
<span class="source-line-no">116</span><span id="line.116">     * generated number (even then, it might be fine).</span>
<span class="source-line-no">117</span><span id="line.117">     * @param seed the initial seed; may be any long</span>
<span class="source-line-no">118</span><span id="line.118">     */</span>
<span class="source-line-no">119</span><span id="line.119">    public void setSeed(long seed) {</span>
<span class="source-line-no">120</span><span id="line.120">        stateA = seed ^ 0xFA346CBFD5890825L;</span>
<span class="source-line-no">121</span><span id="line.121">        if(stateA == 0L) stateA = 0xD3833E804F4C574BL;</span>
<span class="source-line-no">122</span><span id="line.122">        stateB = jump(stateA);</span>
<span class="source-line-no">123</span><span id="line.123">        stateC = jump(stateB - seed);</span>
<span class="source-line-no">124</span><span id="line.124">        stateD = jump(stateC + 0xC6BC279692B5C323L);</span>
<span class="source-line-no">125</span><span id="line.125">    }</span>
<span class="source-line-no">126</span><span id="line.126"></span>
<span class="source-line-no">127</span><span id="line.127">    public long getStateA() {</span>
<span class="source-line-no">128</span><span id="line.128">        return stateA;</span>
<span class="source-line-no">129</span><span id="line.129">    }</span>
<span class="source-line-no">130</span><span id="line.130"></span>
<span class="source-line-no">131</span><span id="line.131">    /**</span>
<span class="source-line-no">132</span><span id="line.132">     * Sets the first part of the state.</span>
<span class="source-line-no">133</span><span id="line.133">     * @param stateA can be any long except 0; this treats 0 as 0xD3833E804F4C574BL</span>
<span class="source-line-no">134</span><span id="line.134">     */</span>
<span class="source-line-no">135</span><span id="line.135">    public void setStateA(long stateA) {</span>
<span class="source-line-no">136</span><span id="line.136">        this.stateA = (stateA == 0L) ? 0xD3833E804F4C574BL : stateA;</span>
<span class="source-line-no">137</span><span id="line.137">    }</span>
<span class="source-line-no">138</span><span id="line.138"></span>
<span class="source-line-no">139</span><span id="line.139">    public long getStateB() {</span>
<span class="source-line-no">140</span><span id="line.140">        return stateB;</span>
<span class="source-line-no">141</span><span id="line.141">    }</span>
<span class="source-line-no">142</span><span id="line.142"></span>
<span class="source-line-no">143</span><span id="line.143">    /**</span>
<span class="source-line-no">144</span><span id="line.144">     * Sets the second part of the state.</span>
<span class="source-line-no">145</span><span id="line.145">     * @param stateB can be any long except 0; this treats 0 as 0x790B300BF9FE738FL</span>
<span class="source-line-no">146</span><span id="line.146">     */</span>
<span class="source-line-no">147</span><span id="line.147">    public void setStateB(long stateB) {</span>
<span class="source-line-no">148</span><span id="line.148">        this.stateB = (stateB == 0L) ? 0x790B300BF9FE738FL : stateB;</span>
<span class="source-line-no">149</span><span id="line.149">    }</span>
<span class="source-line-no">150</span><span id="line.150"></span>
<span class="source-line-no">151</span><span id="line.151">    public long getStateC() {</span>
<span class="source-line-no">152</span><span id="line.152">        return stateC;</span>
<span class="source-line-no">153</span><span id="line.153">    }</span>
<span class="source-line-no">154</span><span id="line.154"></span>
<span class="source-line-no">155</span><span id="line.155">    /**</span>
<span class="source-line-no">156</span><span id="line.156">     * Sets the third part of the state. Note that if you call {@link #nextLong()}</span>
<span class="source-line-no">157</span><span id="line.157">     * immediately after this, it will return the given {@code stateC} as-is, so you</span>
<span class="source-line-no">158</span><span id="line.158">     * may want to call some random generation methods (such as nextLong()) and discard</span>
<span class="source-line-no">159</span><span id="line.159">     * the results after setting the state.</span>
<span class="source-line-no">160</span><span id="line.160">     * @param stateC can be any long</span>
<span class="source-line-no">161</span><span id="line.161">     */</span>
<span class="source-line-no">162</span><span id="line.162">    public void setStateC(long stateC) {</span>
<span class="source-line-no">163</span><span id="line.163">        this.stateC = stateC;</span>
<span class="source-line-no">164</span><span id="line.164">    }</span>
<span class="source-line-no">165</span><span id="line.165"></span>
<span class="source-line-no">166</span><span id="line.166">    public long getStateD() {</span>
<span class="source-line-no">167</span><span id="line.167">        return stateD;</span>
<span class="source-line-no">168</span><span id="line.168">    }</span>
<span class="source-line-no">169</span><span id="line.169"></span>
<span class="source-line-no">170</span><span id="line.170">    /**</span>
<span class="source-line-no">171</span><span id="line.171">     * Sets the fourth part of the state.</span>
<span class="source-line-no">172</span><span id="line.172">     * @param stateD can be any long</span>
<span class="source-line-no">173</span><span id="line.173">     */</span>
<span class="source-line-no">174</span><span id="line.174">    public void setStateD(long stateD) {</span>
<span class="source-line-no">175</span><span id="line.175">        this.stateD = stateD;</span>
<span class="source-line-no">176</span><span id="line.176">    }</span>
<span class="source-line-no">177</span><span id="line.177"></span>
<span class="source-line-no">178</span><span id="line.178">    /**</span>
<span class="source-line-no">179</span><span id="line.179">     * Sets the state completely to the given four state variables, unless stateA or stateB are 0.</span>
<span class="source-line-no">180</span><span id="line.180">     * This is the same as calling {@link #setStateA(long)}, {@link #setStateB(long)},</span>
<span class="source-line-no">181</span><span id="line.181">     * {@link #setStateC(long)}, and {@link #setStateD(long)} as a group. You may want</span>
<span class="source-line-no">182</span><span id="line.182">     * to call {@link #nextLong()} a few times after setting the states like this, unless</span>
<span class="source-line-no">183</span><span id="line.183">     * the value for stateC (in particular) is already adequately random; the first call</span>
<span class="source-line-no">184</span><span id="line.184">     * to {@link #nextLong()}, if it is made immediately after calling this, will return {@code stateC} as-is.</span>
<span class="source-line-no">185</span><span id="line.185">     * @param stateA the first state; can be any long; can be any long except 0</span>
<span class="source-line-no">186</span><span id="line.186">     * @param stateB the second state; can be any long; can be any long except 0</span>
<span class="source-line-no">187</span><span id="line.187">     * @param stateC the third state; this will be returned as-is if the next call is to {@link #nextLong()}</span>
<span class="source-line-no">188</span><span id="line.188">     * @param stateD the fourth state; can be any long</span>
<span class="source-line-no">189</span><span id="line.189">     */</span>
<span class="source-line-no">190</span><span id="line.190">    public void setState(long stateA, long stateB, long stateC, long stateD) {</span>
<span class="source-line-no">191</span><span id="line.191">        this.stateA = (stateA == 0L) ? 0xD3833E804F4C574BL : stateA;</span>
<span class="source-line-no">192</span><span id="line.192">        this.stateB = (stateB == 0L) ? 0x790B300BF9FE738FL : stateB;</span>
<span class="source-line-no">193</span><span id="line.193">        this.stateC = stateC;</span>
<span class="source-line-no">194</span><span id="line.194">        this.stateD = stateD;</span>
<span class="source-line-no">195</span><span id="line.195">    }</span>
<span class="source-line-no">196</span><span id="line.196"></span>
<span class="source-line-no">197</span><span id="line.197">    /**</span>
<span class="source-line-no">198</span><span id="line.198">     * Sets the state with three variables, ensuring that the result has states A and B</span>
<span class="source-line-no">199</span><span id="line.199">     * sufficiently separated from each other, while keeping states C and D as given.</span>
<span class="source-line-no">200</span><span id="line.200">     * Note that this does not take a stateB parameter, and instead obtains it by jumping</span>
<span class="source-line-no">201</span><span id="line.201">     * stateA ahead by about 11.4 quintillion steps using {@link #jump(long)}. If stateA is</span>
<span class="source-line-no">202</span><span id="line.202">     * given as 0, this uses 0xD3833E804F4C574BL instead for stateA and 0x790B300BF9FE738FL</span>
<span class="source-line-no">203</span><span id="line.203">     * for stateB. States C and D can each be any long.</span>
<span class="source-line-no">204</span><span id="line.204">     * @param stateA the long value to use for stateA and also used to get stateB; can be any long except 0</span>
<span class="source-line-no">205</span><span id="line.205">     * @param stateC the long value to use for stateC; this will be returned as-is if the next call is to {@link #nextLong()}</span>
<span class="source-line-no">206</span><span id="line.206">     * @param stateD the long value to use for stateD; can be any long</span>
<span class="source-line-no">207</span><span id="line.207">     */</span>
<span class="source-line-no">208</span><span id="line.208">    public void setState (long stateA, long stateC, long stateD) {</span>
<span class="source-line-no">209</span><span id="line.209">        this.stateA = (stateA == 0L) ? 0xD3833E804F4C574BL : stateA;</span>
<span class="source-line-no">210</span><span id="line.210">        this.stateB = jump(this.stateA);</span>
<span class="source-line-no">211</span><span id="line.211">        this.stateC = stateC;</span>
<span class="source-line-no">212</span><span id="line.212">        this.stateD = stateD;</span>
<span class="source-line-no">213</span><span id="line.213">    }</span>
<span class="source-line-no">214</span><span id="line.214"></span>
<span class="source-line-no">215</span><span id="line.215">    /**</span>
<span class="source-line-no">216</span><span id="line.216">     * Using this method, any algorithm that might use the built-in Java Random</span>
<span class="source-line-no">217</span><span id="line.217">     * can interface with this randomness source.</span>
<span class="source-line-no">218</span><span id="line.218">     *</span>
<span class="source-line-no">219</span><span id="line.219">     * @param bits the number of bits to be returned</span>
<span class="source-line-no">220</span><span id="line.220">     * @return the integer containing the appropriate number of bits</span>
<span class="source-line-no">221</span><span id="line.221">     */</span>
<span class="source-line-no">222</span><span id="line.222">    @Override</span>
<span class="source-line-no">223</span><span id="line.223">    public int next(final int bits) {</span>
<span class="source-line-no">224</span><span id="line.224">        final long fa = this.stateA;</span>
<span class="source-line-no">225</span><span id="line.225">        final long fb = this.stateB;</span>
<span class="source-line-no">226</span><span id="line.226">        final long fc = this.stateC;</span>
<span class="source-line-no">227</span><span id="line.227">        final long fd = this.stateD;</span>
<span class="source-line-no">228</span><span id="line.228">        this.stateA = fb ^ fb &lt;&lt; 7;</span>
<span class="source-line-no">229</span><span id="line.229">        this.stateB = fa ^ fa &gt;&gt;&gt; 9;</span>
<span class="source-line-no">230</span><span id="line.230">        this.stateC = Long.rotateLeft(fd, 39) - fb;</span>
<span class="source-line-no">231</span><span id="line.231">        this.stateD = fa - fc + 0xC6BC279692B5C323L;</span>
<span class="source-line-no">232</span><span id="line.232">        return (int)fc &gt;&gt;&gt; (32 - bits);</span>
<span class="source-line-no">233</span><span id="line.233">    }</span>
<span class="source-line-no">234</span><span id="line.234">    /**</span>
<span class="source-line-no">235</span><span id="line.235">     * Using this method, any algorithm that needs to efficiently generate more</span>
<span class="source-line-no">236</span><span id="line.236">     * than 32 bits of random data can interface with this randomness source.</span>
<span class="source-line-no">237</span><span id="line.237">     * &lt;p&gt;</span>
<span class="source-line-no">238</span><span id="line.238">     * Get a random long between Long.MIN_VALUE and Long.MAX_VALUE (both inclusive).</span>
<span class="source-line-no">239</span><span id="line.239">     *</span>
<span class="source-line-no">240</span><span id="line.240">     * @return a random long between Long.MIN_VALUE and Long.MAX_VALUE (both inclusive)</span>
<span class="source-line-no">241</span><span id="line.241">     */</span>
<span class="source-line-no">242</span><span id="line.242">    @Override</span>
<span class="source-line-no">243</span><span id="line.243">    public long nextLong() {</span>
<span class="source-line-no">244</span><span id="line.244">        final long fa = this.stateA;</span>
<span class="source-line-no">245</span><span id="line.245">        final long fb = this.stateB;</span>
<span class="source-line-no">246</span><span id="line.246">        final long fc = this.stateC;</span>
<span class="source-line-no">247</span><span id="line.247">        final long fd = this.stateD;</span>
<span class="source-line-no">248</span><span id="line.248">        this.stateA = fb ^ fb &lt;&lt; 7;</span>
<span class="source-line-no">249</span><span id="line.249">        this.stateB = fa ^ fa &gt;&gt;&gt; 9;</span>
<span class="source-line-no">250</span><span id="line.250">        this.stateC = Long.rotateLeft(fd, 39) - fb;</span>
<span class="source-line-no">251</span><span id="line.251">        this.stateD = fa - fc + 0xC6BC279692B5C323L;</span>
<span class="source-line-no">252</span><span id="line.252">        return fc;</span>
<span class="source-line-no">253</span><span id="line.253">    }</span>
<span class="source-line-no">254</span><span id="line.254"></span>
<span class="source-line-no">255</span><span id="line.255">    /**</span>
<span class="source-line-no">256</span><span id="line.256">     * Produces a copy of this RandomnessSource that, if next() and/or nextLong() are called on this object and the</span>
<span class="source-line-no">257</span><span id="line.257">     * copy, both will generate the same sequence of random numbers from the point copy() was called. This just need to</span>
<span class="source-line-no">258</span><span id="line.258">     * copy the state so it isn't shared, usually, and produce a new value with the same exact state.</span>
<span class="source-line-no">259</span><span id="line.259">     *</span>
<span class="source-line-no">260</span><span id="line.260">     * @return a copy of this RandomnessSource</span>
<span class="source-line-no">261</span><span id="line.261">     */</span>
<span class="source-line-no">262</span><span id="line.262">    @Override</span>
<span class="source-line-no">263</span><span id="line.263">    public StrangerRNG copy() {</span>
<span class="source-line-no">264</span><span id="line.264">        return new StrangerRNG(stateA, stateB, stateC, stateD);</span>
<span class="source-line-no">265</span><span id="line.265">    }</span>
<span class="source-line-no">266</span><span id="line.266">    @Override</span>
<span class="source-line-no">267</span><span id="line.267">    public String toString() {</span>
<span class="source-line-no">268</span><span id="line.268">        return "StrangerRNG with stateA 0x" + StringKit.hex(stateA) + "L, stateB 0x" + StringKit.hex(stateB)</span>
<span class="source-line-no">269</span><span id="line.269">                + "L, stateC 0x" + StringKit.hex(stateC) + "L, and stateD 0x" + StringKit.hex(stateD) + 'L';</span>
<span class="source-line-no">270</span><span id="line.270">    }</span>
<span class="source-line-no">271</span><span id="line.271"></span>
<span class="source-line-no">272</span><span id="line.272">    @Override</span>
<span class="source-line-no">273</span><span id="line.273">    public boolean equals(Object o) {</span>
<span class="source-line-no">274</span><span id="line.274">        if (this == o) return true;</span>
<span class="source-line-no">275</span><span id="line.275">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="source-line-no">276</span><span id="line.276"></span>
<span class="source-line-no">277</span><span id="line.277">        StrangerRNG strangerRNG = (StrangerRNG) o;</span>
<span class="source-line-no">278</span><span id="line.278"></span>
<span class="source-line-no">279</span><span id="line.279">        return stateA == strangerRNG.stateA &amp;&amp; stateB == strangerRNG.stateB &amp;&amp; stateC == strangerRNG.stateC</span>
<span class="source-line-no">280</span><span id="line.280">                &amp;&amp; stateD == strangerRNG.stateD;</span>
<span class="source-line-no">281</span><span id="line.281">    }</span>
<span class="source-line-no">282</span><span id="line.282"></span>
<span class="source-line-no">283</span><span id="line.283">    @Override</span>
<span class="source-line-no">284</span><span id="line.284">    public int hashCode() {</span>
<span class="source-line-no">285</span><span id="line.285">        return (int) (9689L * (stateA ^ (stateA &gt;&gt;&gt; 32)) + 421L * (stateB ^ (stateB &gt;&gt;&gt; 32)) + 29L * (stateC ^ (stateC &gt;&gt;&gt; 32)) + (stateD ^ stateD &gt;&gt;&gt; 32));</span>
<span class="source-line-no">286</span><span id="line.286">    }</span>
<span class="source-line-no">287</span><span id="line.287">}</span>




























































</pre>
</div>
</main>
</body>
</html>
